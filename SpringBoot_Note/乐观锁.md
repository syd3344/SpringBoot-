## 概述

> - 是一种在并发场景下保护数据一致性的方法，它的基本思想是假设多个事务在处理数据时不会产生冲突，乐观地认为不会有数据竞争，因此不在每次操作前对数据加锁。
> - 只有在更新数据时，才会进行数据冲突的校验。这种方式常用于高并发环境中，以减少锁的使用，提升系统性能。

## 实现方式

> - 乐观锁通常通过“**版本号机制**”或“**时间戳机制**”来实现。

### 版本号

> **概述**
>
> - 每个数据记录中增加一个 `version` 字段。
> - 每次读取数据时，将 `version` 一起读取出来，更新数据时需要同时检查 `version` 是否和之前读取时一致。
> - 如果一致，说明数据没有被其他事务修改，允许更新；
> - 如果不一致，则说明数据已经被其他事务修改，更新失败。

> **步骤**
>
> - 查询时，读取 `version` 字段。
> - 更新时，使用条件语句来比较 `version` 值，比如 `UPDATE table SET ... WHERE id=? AND version=?`。
>   - 如果 `version` 匹配，则执行更新，同时将 `version` 增加（例如 `version = version + 1`）；
>   - 否则更新失败，需要重新尝试。

> **实现**
>
> ```java
> //假设 version 初始为 1
> UPDATE employee
> SET salary = 5000, version = version + 1
> WHERE id = 123 AND version = 1;
> ```
>
> 

### 时间戳

> **概述**
>
> - 另一种方法是使用数据记录的**更新时间戳**（例如 `update_time` 字段）。
> - 每次更新数据时，会比较当前时间和上次更新时间，只有当数据未被其他事务修改过，才允许更新。

```java
UPDATE employee
SET salary = 5000, update_time = NOW()
WHERE id = 123 AND update_time = '2023-09-01 12:00:00';

```















































