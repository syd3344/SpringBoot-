## 概述

> - 数据库的锁机制是用于管理多个并发事务对同一数据资源的访问，以确保数据的一致性和完整性，防止并发操作引起的数据冲突或异常。
> - 锁机制通过对数据加锁，使事务在访问或修改数据时避免与其他事务产生冲突。
> - 不同数据库系统通常会实现不同类型的锁，主要分为行级锁、表级锁等。

## 分类

> - 根据不同标准进行分类

### 按锁的粒度

#### 行级锁

> - 针对数据表中的某一行记录加锁 
> - 锁的粒度小，允许多个事务同时访问同一张表的不同行，提高并发性能
> - 代价是是锁的管理开销比较大

#### 表级锁

> - 锁住整个表
> - 一个事务锁定了整张表，其他事务无法同时对表进行操作
> - 管理开销低，但并发性差

### 按锁的操作类型

#### 共享锁

> - 允许多个事务同时读取统一资源，但不能修改数据
> - 允许并发读取，但防止其他事务进行修改

#### 排他锁

> - 独占数据，锁定资源不能被其他事务读取或修改，直到当前事务释放锁
> - 排他锁通常用于写操作

### 按锁的实现方式

### 悲观锁

> - 数据在并发操作时极有可能发生冲突

### 乐观锁

> - 假设并发操作的冲突很少

### 按锁的范围

### 意向锁

> - 意向锁是数据库为了提升锁机制性能而设计的锁种类。
> - 它表明事务计划对某个资源（表或行）加锁。
> - 意向锁本身不会阻塞其他事务，但帮助数据库快速确定某个资源是否已经被其他事务锁定。

## 死锁（Deadlock）与锁超时

> - 在数据库锁机制中，如果两个事务各自持有对方所需的资源锁，就会产生**死锁**

### 避免死锁的机制

#### 死锁检测

> - 数据库会定期检查锁的依赖关系图，发现死锁时，会主动回滚其中一个事务。

#### 锁超时

> - 在等待锁的过程中，如果超过了指定时间，数据库会回滚当前事务，防止长期等待。

